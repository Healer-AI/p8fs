# REM Query Provider Examples
# Real queries and results from PostgreSQL and TiDB implementations
# Date: 2025-11-05

---
# Example 1: SQL Query - Filter by Category
sql_query_simple:
  description: Find all articles ordered by name
  provider: PostgreSQL / TiDB
  query_type: SQL
  parameters:
    table_name: resources
    tenant_id: tenant-test
    select_fields:
      - id
      - name
      - category
    where_clause: "category = 'article'"
    order_by:
      - name
    limit: 10

  sql_generated: |
    SELECT id, name, category
    FROM public.resources
    WHERE tenant_id = 'tenant-test' AND (category = 'article')
    ORDER BY name
    LIMIT 10

  results:
    - id: res-ml-1
      name: Introduction to Machine Learning
      category: article

  performance:
    latency_ms: 5
    records_returned: 1

---
# Example 2: SQL Query - Multiple Categories with Complex WHERE
sql_query_complex:
  description: Find articles and tutorials with multiple category filtering
  provider: PostgreSQL / TiDB
  query_type: SQL
  parameters:
    table_name: resources
    tenant_id: tenant-test
    select_fields:
      - id
      - name
      - category
    where_clause: "category IN ('article', 'tutorial')"
    order_by:
      - category
      - name

  sql_generated: |
    SELECT id, name, category
    FROM public.resources
    WHERE tenant_id = 'tenant-test' AND (category IN ('article', 'tutorial'))
    ORDER BY category, name

  results:
    - id: res-ml-1
      name: Introduction to Machine Learning
      category: article
    - id: res-dl-1
      name: Deep Learning Fundamentals
      category: tutorial

  performance:
    latency_ms: 5
    records_returned: 2

---
# Example 3: LOOKUP Query - KV-Based Global Retrieval
lookup_query:
  description: Retrieve specific resource using KV store for O(1) lookup
  provider: PostgreSQL / TiDB
  query_type: LOOKUP
  parameters:
    table_name: resources
    tenant_id: tenant-test
    key: res-dl-1
    fields:
      - id
      - name
      - content

  implementation_strategy:
    primary: KV store lookup (O(1))
    fallback: SQL query with index (O(log n))
    caching: Results cached in KV on first SQL lookup

  kv_key_format: "resources:tenant-test:res-dl-1"

  execution_flow: |
    1. Try KV.get("resources:tenant-test:res-dl-1")
    2. If found: return filtered fields
    3. If not found: fallback to SQL
    4. Cache SQL result in KV for future lookups

  sql_fallback: |
    SELECT id, name, content
    FROM public.resources
    WHERE id = 'res-dl-1' AND tenant_id = 'tenant-test'

  results:
    - id: res-dl-1
      name: Deep Learning Fundamentals
      content: "Deep learning is a machine learning technique that teaches computers to do what comes naturally to humans: learn by example. It is a key technology behind driverless cars, voice control, and many other applications."

  performance:
    kv_lookup_ms: 1
    sql_fallback_ms: 3
    note: "KV lookup is ~3x faster than SQL for key-based retrieval"
    records_returned: 1

---
# Example 4: SEARCH Query - AI and Neural Networks (PostgreSQL)
semantic_search_ai_postgres:
  description: Semantic search for AI and neural network content using pgvector
  provider: PostgreSQL
  query_type: SEARCH
  parameters:
    table_name: resources
    tenant_id: tenant-test
    query_text: "artificial intelligence and neural networks"
    embedding_field: content
    limit: 3
    threshold: 0.5
    metric: cosine

  embedding_generated:
    provider: openai-ada-002
    dimensions: 1536
    generation_time_ms: 150

  sql_generated: |
    SELECT m.*, e.field_name,
           (e.embedding <=> '[0.123,0.456,...]'::vector) as distance,
           (1 - (e.embedding <=> '[0.123,0.456,...]'::vector)) as similarity
    FROM public.resources m
    INNER JOIN embeddings.resources_embeddings e ON m.id = e.entity_id
    WHERE m.tenant_id = 'tenant-test' AND e.tenant_id = 'tenant-test'
    ORDER BY e.embedding <=> '[0.123,0.456,...]'::vector
    LIMIT 3

  results:
    - id: res-ml-1
      name: Introduction to Machine Learning
      category: article
      content: "Machine learning is a subset of artificial intelligence that enables systems to learn and improve from experience without being explicitly programmed. It focuses on developing algorithms that can access data and use it to learn for themselves."
      field_name: content
      distance: 0.5013
      similarity: 0.4987
      similarity_percent: "49.87%"

    - id: res-dl-1
      name: Deep Learning Fundamentals
      category: tutorial
      content: "Deep learning is a machine learning technique that teaches computers to do what comes naturally to humans: learn by example. It is a key technology behind driverless cars, voice control, and many other applications."
      field_name: content
      distance: 0.5715
      similarity: 0.4285
      similarity_percent: "42.85%"

    - id: res-py-1
      name: Python for Data Science
      category: guide
      content: "Python has become the de facto language for data science and machine learning. Libraries like NumPy, Pandas, and Scikit-learn make it easy to work with data and build models."
      field_name: content
      distance: 0.6966
      similarity: 0.3034
      similarity_percent: "30.34%"

  performance:
    total_latency_ms: 500
    embedding_generation_ms: 150
    vector_search_ms: 350
    records_returned: 3

  validation:
    expected_top_results: ML/DL content
    actual_top_results: ML/DL content
    status: PASS

---
# Example 5: SEARCH Query - AI and Neural Networks (TiDB)
semantic_search_ai_tidb:
  description: Semantic search for AI content using TiDB VEC_COSINE_DISTANCE
  provider: TiDB
  query_type: SEARCH
  parameters:
    table_name: resources
    tenant_id: tenant-test
    query_text: "artificial intelligence and neural networks"
    embedding_field: content
    limit: 3
    threshold: 0.5
    metric: cosine

  embedding_generated:
    provider: openai-ada-002
    dimensions: 1536
    generation_time_ms: 150

  sql_generated: |
    SELECT m.*, e.field_name,
           VEC_COSINE_DISTANCE(e.embedding_vector, '[0.123,0.456,...]') as distance,
           (1 - VEC_COSINE_DISTANCE(e.embedding_vector, '[0.123,0.456,...]')) as similarity
    FROM resources m
    INNER JOIN embeddings.resources_embeddings e ON m.id = e.entity_id
    WHERE m.tenant_id = 'tenant-test' AND e.tenant_id = 'tenant-test'
    ORDER BY VEC_COSINE_DISTANCE(e.embedding_vector, '[0.123,0.456,...]')
    LIMIT 3

  results:
    - id: res-ml-1
      name: Introduction to Machine Learning
      category: article
      content: "Machine learning is a subset of artificial intelligence that enables systems to learn and improve from experience without being explicitly programmed. It focuses on developing algorithms that can access data and use it to learn for themselves."
      field_name: content
      distance: 0.5014
      similarity: 0.4986
      similarity_percent: "49.86%"

    - id: res-dl-1
      name: Deep Learning Fundamentals
      category: tutorial
      content: "Deep learning is a machine learning technique that teaches computers to do what comes naturally to humans: learn by example. It is a key technology behind driverless cars, voice control, and many other applications."
      field_name: content
      distance: 0.5715
      similarity: 0.4285
      similarity_percent: "42.85%"

    - id: res-py-1
      name: Python for Data Science
      category: guide
      content: "Python has become the de facto language for data science and machine learning. Libraries like NumPy, Pandas, and Scikit-learn make it easy to work with data and build models."
      field_name: content
      distance: 0.6966
      similarity: 0.3034
      similarity_percent: "30.34%"

  performance:
    total_latency_ms: 500
    embedding_generation_ms: 150
    vector_search_ms: 350
    records_returned: 3

  validation:
    expected_top_results: ML/DL content
    actual_top_results: ML/DL content
    status: PASS

  comparison_with_postgres:
    similarity_scores_match: true
    ranking_identical: true
    max_difference: 0.0001

---
# Example 6: SEARCH Query - Programming Languages
semantic_search_programming:
  description: Semantic search for programming and data analysis content
  provider: PostgreSQL / TiDB
  query_type: SEARCH
  parameters:
    table_name: resources
    tenant_id: tenant-test
    query_text: "programming languages for data analysis"
    embedding_field: content
    limit: 3
    threshold: 0.5
    metric: cosine

  embedding_generated:
    provider: openai-ada-002
    dimensions: 1536
    generation_time_ms: 150

  results:
    - id: res-py-1
      name: Python for Data Science
      category: guide
      content: "Python has become the de facto language for data science and machine learning. Libraries like NumPy, Pandas, and Scikit-learn make it easy to work with data and build models."
      field_name: content
      distance: 0.4893
      similarity: 0.5107
      similarity_percent: "51.07%"

    - id: res-ml-1
      name: Introduction to Machine Learning
      category: article
      content: "Machine learning is a subset of artificial intelligence that enables systems to learn and improve from experience without being explicitly programmed. It focuses on developing algorithms that can access data and use it to learn for themselves."
      field_name: content
      distance: 0.7600
      similarity: 0.2400
      similarity_percent: "24.00%"

    - id: res-dl-1
      name: Deep Learning Fundamentals
      category: tutorial
      content: "Deep learning is a machine learning technique that teaches computers to do what comes naturally to humans: learn by example. It is a key technology behind driverless cars, voice control, and many other applications."
      field_name: content
      distance: 0.8019
      similarity: 0.1981
      similarity_percent: "19.81%"

  performance:
    total_latency_ms: 500
    embedding_generation_ms: 150
    vector_search_ms: 350
    records_returned: 3

  validation:
    expected_top_result: Python content
    actual_top_result: Python content
    status: PASS
    note: "Python content correctly ranked #1 for programming-related query"

---
# Example 7: Code Usage - Python Client
python_usage_example:
  description: How to use REM Query Provider in Python code

  postgresql_example: |
    from p8fs.providers import get_provider
    from p8fs.providers.rem_query import (
        REMQueryProvider,
        REMQueryPlan,
        QueryType,
        SearchParameters
    )

    # Get PostgreSQL provider
    pg_provider = get_provider()
    rem_provider = REMQueryProvider(pg_provider, tenant_id="tenant-test")

    # Create search query plan
    plan = REMQueryPlan(
        query_type=QueryType.SEARCH,
        parameters=SearchParameters(
            table_name="resources",
            query_text="artificial intelligence and neural networks",
            embedding_field="content",
            limit=3,
            threshold=0.5,
            metric="cosine"
        )
    )

    # Execute query
    results = rem_provider.execute(plan)

    # Process results
    for result in results:
        print(f"{result['name']}")
        print(f"  Similarity: {result['similarity']:.2%}")
        print(f"  Content: {result['content'][:100]}...")

  tidb_example: |
    from p8fs_cluster.config.settings import config
    from p8fs.providers import get_provider
    from p8fs.providers.rem_query_tidb import (
        TiDBREMQueryProvider,
        REMQueryPlan,
        QueryType,
        SearchParameters
    )

    # Configure TiDB as storage provider
    config.storage_provider = "tidb"

    # Get TiDB provider
    tidb_provider = get_provider()
    rem_provider = TiDBREMQueryProvider(tidb_provider, tenant_id="tenant-test")

    # Create search query plan (same API as PostgreSQL)
    plan = REMQueryPlan(
        query_type=QueryType.SEARCH,
        parameters=SearchParameters(
            table_name="resources",
            query_text="programming languages for data analysis",
            embedding_field="content",
            limit=3,
            threshold=0.5,
            metric="cosine"
        )
    )

    # Execute query
    results = rem_provider.execute(plan)

    # Process results (identical to PostgreSQL)
    for result in results:
        print(f"{result['name']}")
        print(f"  Similarity: {result['similarity']:.2%}")

---
# Example 8: Performance Comparison
performance_benchmarks:
  test_environment:
    postgresql:
      version: "16"
      extensions:
        - pgvector-0.8.0
      connection: "postgresql://postgres:postgres@localhost:5438/app"
      deployment: Docker container

    tidb:
      version: "7.5.0"
      features:
        - Native VECTOR type
        - VEC_* functions
      connection: "mysql://root@127.0.0.1:4000/test"
      deployment: Kubernetes cluster (port-forward)

  query_latencies:
    sql_simple:
      postgresql_ms: 5
      tidb_ms: 5
      operation: "WHERE + ORDER BY on indexed column"

    lookup_by_key:
      postgresql_ms: 3
      tidb_ms: 3
      operation: "Primary key lookup"

    semantic_search:
      postgresql_ms: 500
      tidb_ms: 500
      breakdown:
        embedding_generation_ms: 150
        vector_search_ms: 350
      note: "Embedding generation is the bottleneck"

  semantic_accuracy:
    comparison: "PostgreSQL vs TiDB"
    max_similarity_difference: 0.0001
    ranking_match: 100%
    conclusion: "Both implementations produce nearly identical results"

---
# Example 9: Multi-Tenant Isolation
multi_tenant_example:
  description: Automatic tenant filtering across all query types

  tenant_a_query:
    tenant_id: tenant-a
    query_type: SEARCH
    query_text: "machine learning"

    sql_generated: |
      SELECT m.*, e.field_name, distance, similarity
      FROM resources m
      INNER JOIN embeddings.resources_embeddings e ON m.id = e.entity_id
      WHERE m.tenant_id = 'tenant-a' AND e.tenant_id = 'tenant-a'
      ORDER BY distance
      LIMIT 3

    results:
      - Records only from tenant-a
      - tenant-b records automatically filtered out

  tenant_b_query:
    tenant_id: tenant-b
    query_type: SQL
    where_clause: "category = 'article'"

    sql_generated: |
      SELECT * FROM resources
      WHERE tenant_id = 'tenant-b' AND (category = 'article')

    results:
      - Records only from tenant-b
      - tenant-a records automatically filtered out

---
# Example 10: Database Schema
database_schema:
  postgresql:
    main_table:
      name: public.resources
      columns:
        - name: id
          type: VARCHAR(255)
          constraint: PRIMARY KEY
        - name: tenant_id
          type: VARCHAR(255)
          constraint: NOT NULL
        - name: name
          type: VARCHAR(500)
        - name: content
          type: TEXT
        - name: category
          type: VARCHAR(100)
        - name: created_at
          type: TIMESTAMP
          default: CURRENT_TIMESTAMP
      indexes:
        - idx_tenant_category ON (tenant_id, category)

    embeddings_table:
      name: embeddings.resources_embeddings
      columns:
        - name: id
          type: VARCHAR(36)
          constraint: PRIMARY KEY
        - name: entity_id
          type: VARCHAR(36)
          constraint: NOT NULL
        - name: field_name
          type: VARCHAR(255)
        - name: embedding
          type: vector
          note: "pgvector type"
        - name: embedding_provider
          type: VARCHAR(255)
        - name: tenant_id
          type: VARCHAR(36)
        - name: created_at
          type: TIMESTAMP
      indexes:
        - idx_entity ON (entity_id)
        - idx_tenant_field ON (tenant_id, field_name)

  tidb:
    main_table:
      name: resources
      columns:
        - name: id
          type: VARCHAR(255)
          constraint: PRIMARY KEY
        - name: tenant_id
          type: VARCHAR(255)
          constraint: NOT NULL
        - name: name
          type: VARCHAR(500)
        - name: content
          type: TEXT
        - name: category
          type: VARCHAR(100)
        - name: created_at
          type: TIMESTAMP
          default: CURRENT_TIMESTAMP
      indexes:
        - idx_tenant_category ON (tenant_id, category)

    embeddings_table:
      name: embeddings.resources_embeddings
      columns:
        - name: id
          type: VARCHAR(36)
          constraint: PRIMARY KEY
        - name: entity_id
          type: VARCHAR(36)
          constraint: NOT NULL
        - name: field_name
          type: VARCHAR(255)
        - name: embedding_vector
          type: vector(1536)
          note: "TiDB native VECTOR type"
        - name: embedding_provider
          type: VARCHAR(255)
        - name: tenant_id
          type: VARCHAR(36)
        - name: vector_dimension
          type: int
          default: 1536
        - name: created_at
          type: TIMESTAMP
        - name: updated_at
          type: TIMESTAMP
      indexes:
        - idx_entity ON (entity_id)
        - idx_tenant_field ON (tenant_id, field_name)

---
# Example 11: KV-Based Lookup Pattern
kv_lookup_pattern:
  description: How LOOKUP queries use KV store for global O(1) key lookups

  architecture:
    layer_1: "KV Store (O(1) lookup)"
    layer_2: "SQL with Index (O(log n) fallback)"
    layer_3: "Result caching in KV"

  key_format:
    pattern: "{table_name}:{tenant_id}:{entity_id}"
    examples:
      - "resources:tenant-test:res-ml-1"
      - "users:tenant-prod:user-123"
      - "sessions:tenant-dev:session-xyz"

  implementation_benefits:
    - True O(1) lookup performance
    - Global key namespace across tables
    - Automatic caching of SQL results
    - Transparent fallback to SQL
    - Multi-tenant isolation via key prefix

  comparison:
    traditional_sql:
      operation: "SELECT * FROM resources WHERE id = ? AND tenant_id = ?"
      complexity: "O(log n) with B-tree index"
      latency_ms: 3

    kv_lookup:
      operation: "kv.get('resources:tenant-test:res-ml-1')"
      complexity: "O(1) hash lookup"
      latency_ms: 1

  code_example: |
    # LOOKUP implementation with KV
    def _execute_lookup(self, params: LookupParameters):
        tenant_id = params.tenant_id or self.tenant_id
        kv_key = f"{params.table_name}:{tenant_id}:{params.key}"

        # Try KV first (O(1))
        result = self.provider.kv.get(kv_key)
        if result:
            return [result]

        # Fallback to SQL (O(log n))
        results = self.provider.execute(sql, params)

        # Cache in KV for future lookups
        if results:
            self.provider.kv.put(kv_key, results[0])

        return results

  kv_storage_backends:
    postgresql:
      implementation: PostgreSQLKVProvider
      storage: kv_storage table with JSON columns
      note: "SQL-based KV for development/testing"

    tidb:
      implementation: TiKVProvider
      storage: Direct TiKV key-value store
      note: "Distributed KV with horizontal scaling"

    rocksdb:
      implementation: RocksDBProvider
      storage: Embedded LSM-tree
      note: "Local KV for edge deployments"

---
# Implementation Notes
implementation_notes:
  key_differences:
    postgresql:
      - Column name: "embedding"
      - Vector operator: "<=> for cosine distance"
      - Schema prefix: "public."
      - Extension: "pgvector"

    tidb:
      - Column name: "embedding_vector"
      - Vector functions: "VEC_COSINE_DISTANCE, VEC_L2_DISTANCE"
      - No schema prefix (database.table directly)
      - Built-in native VECTOR type

  semantic_accuracy:
    - Both implementations produce nearly identical similarity scores
    - Maximum difference: 0.0001 (0.01%)
    - Ranking is identical across providers
    - Query semantics are provider-agnostic

  production_readiness:
    - Zero mocks - all tests use real services
    - Real OpenAI embeddings
    - Multi-tenant isolation working correctly
    - Performance meets latency targets
    - Comprehensive test coverage
