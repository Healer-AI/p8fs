"""
Integration tests for TiDB reverse key mapping system.

CRITICAL: These tests MUST be integration tests, not unit tests with mocks.
The reverse key mapping system depends on:
1. Real TiDB table IDs generated by the database
2. Actual TiKV binary key computation (t{tableID}_r{encodedPK} format)
3. Complex bidirectional key relationships that only work with real database state
4. Name-based entity lookups that cross-reference multiple storage layers

Mocking any of this would create a false sense of confidence. The system must be tested
against actual TiDB instances with real table creation, key generation, and cross-references.

Test Scenarios:
- Store Resources by name and retrieve them without knowing entity type
- Use generic get_entities method to find entities via reverse mappings
- Verify bidirectional lookups: name -> storage_key -> entity_data -> name
- Test TiKV binary key computation with actual table IDs
- Validate tenant isolation across all reverse mapping layers
"""

from typing import Any
from uuid import uuid4

import pytest
from p8fs_cluster.config.settings import config
from p8fs.models.base import AbstractModel
from p8fs.providers.tidb import TiDBProvider

# Skip all tests in this file until TiDB reverse key mapping is fully implemented
pytestmark = pytest.mark.skip(reason="TiDB reverse key mapping not fully implemented yet")


class SampleResource(AbstractModel):
    """Test resource model for reverse key mapping tests."""
    id: str
    name: str
    content: str
    resource_type: str
    metadata: dict[str, Any] = {}
    
    @classmethod
    def to_sql_schema(cls):
        return {
            'table_name': 'test_resources',
            'key_field': 'id',
            'fields': {
                'id': {'type': str, 'is_primary_key': True},
                'name': {'type': str, 'nullable': False},
                'content': {'type': str, 'nullable': False},
                'resource_type': {'type': str, 'nullable': False},
                'metadata': {'type': dict, 'nullable': True}
            },
            'tenant_isolated': True
        }


class SampleDocument(AbstractModel):
    """Test document model for cross-type reverse mapping tests."""
    id: str
    title: str
    content: str
    
    @classmethod
    def to_sql_schema(cls):
        return {
            'table_name': 'test_documents',
            'key_field': 'id', 
            'fields': {
                'id': {'type': str, 'is_primary_key': True},
                'title': {'type': str, 'nullable': False},
                'content': {'type': str, 'nullable': False}
            },
            'tenant_isolated': True
        }


@pytest.fixture(scope="module")
def tidb_connection():
    """Get real TiDB connection for integration tests."""
    provider = TiDBProvider()
    connection = provider.connect_sync(config.tidb_connection_string)
    yield connection
    connection.close()


@pytest.fixture(scope="module") 
def setup_test_tables(tidb_connection):
    """Set up test tables with real TiDB table creation."""
    provider = TiDBProvider()
    
    # Create test tables - this generates real TiDB table IDs
    resource_sql = provider.create_table_sql(SampleResource)
    document_sql = provider.create_table_sql(SampleDocument)
    kv_mapping_sql = provider.create_kv_mapping_table_sql()
    
    cursor = tidb_connection.cursor()
    
    # Execute table creation
    for sql in [resource_sql, document_sql, kv_mapping_sql]:
        statements = [stmt.strip() for stmt in sql.split(';') if stmt.strip()]
        for statement in statements:
            if statement:
                cursor.execute(statement)
    
    tidb_connection.commit()
    cursor.close()
    
    yield
    
    # Cleanup - drop test tables
    cursor = tidb_connection.cursor()
    try:
        cursor.execute("DROP TABLE IF EXISTS test_resources")
        cursor.execute("DROP TABLE IF EXISTS test_documents") 
        cursor.execute("DROP TABLE IF EXISTS p8fs_kv_mappings")
        tidb_connection.commit()
    except Exception as e:
        print(f"Cleanup warning: {e}")
    finally:
        cursor.close()


class TestTiDBReverseKeyMapping:
    """Integration tests for TiDB reverse key mapping system."""
    
    def test_store_and_retrieve_resource_by_name(self, tidb_connection, setup_test_tables):
        """
        CRITICAL: Test storing Resources by name and retrieving without knowing entity type.
        
        This validates the core reverse mapping flow:
        1. Store resource with name -> creates bidirectional mappings
        2. Lookup by name only -> should find resource without specifying type
        3. Verify all reverse mapping keys are created correctly
        """
        provider = TiDBProvider()
        tenant_id = f"t{str(uuid4())[:8]}"  # Shorter tenant ID to fit column
        
        # Create test resource
        resource_name = "my_test_document"
        resource_data = {
            'id': str(uuid4()),
            'name': resource_name,
            'content': 'This is test content for reverse mapping',
            'resource_type': 'document',
            'metadata': {'source': 'integration_test', 'priority': 'high'}
        }
        
        # Store resource with reverse mapping - this is the critical operation
        entity_key = provider.store_entity_with_reverse_mapping(
            connection=tidb_connection,
            entity_name=resource_name,
            entity_type='SampleResource',
            entity_data=resource_data,
            tenant_id=tenant_id
        )
        
        # Verify entity key format
        assert entity_key == f"{tenant_id}:SampleResource:{resource_name}"
        
        # Test 1: Retrieve by name without specifying entity type
        retrieved_data = provider.get_entity_by_name(
            connection=tidb_connection,
            entity_name=resource_name,
            entity_type='SampleResource',
            tenant_id=tenant_id
        )
        
        assert retrieved_data is not None
        assert retrieved_data['name'] == resource_name
        assert retrieved_data['content'] == 'This is test content for reverse mapping'
        assert retrieved_data['resource_type'] == 'document'
        assert '_reverse_key_metadata' in retrieved_data
        
        # Test 2: Retrieve by storage key (reverse lookup)
        storage_retrieved = provider.get_entities_by_storage_key(
            connection=tidb_connection,
            entity_key=entity_key,
            tenant_id=tenant_id
        )
        
        assert storage_retrieved is not None
        assert storage_retrieved['name'] == resource_name
        assert storage_retrieved['id'] == resource_data['id']
    
    def test_tikv_binary_key_computation_with_real_table_ids(self, tidb_connection, setup_test_tables):
        """
        CRITICAL: Test TiKV binary key computation with actual TiDB table IDs.
        
        This validates that:
        1. We can get real TiDB table IDs from INFORMATION_SCHEMA
        2. Binary key computation works with actual table metadata
        3. The t{tableID}_r{encodedPK} format is correctly generated
        """
        provider = TiDBProvider()
        
        # Get actual table ID from TiDB (not mocked!)
        table_id = provider._get_table_id(tidb_connection, 'test_resources')
        assert table_id is not None, "Should get real TiDB table ID"
        assert isinstance(table_id, int), "Table ID should be integer"
        
        # Test binary key computation with real table ID
        pk_value = "test_resource_123"
        binary_key = provider.compute_tikv_binary_key(table_id, pk_value)
        
        # Verify binary key structure
        assert isinstance(binary_key, bytes)
        expected_prefix = f"t{table_id}_r".encode()
        assert binary_key.startswith(expected_prefix)
        assert b'test_resource_123' in binary_key
    
    def test_metadata_cache_with_real_tables(self, tidb_connection, setup_test_tables):
        """
        Test table metadata caching with real TiDB tables.
        
        Validates that:
        1. Cache correctly stores real table IDs
        2. Primary key information is accurately cached
        3. Table existence checks work with actual database state
        """
        provider = TiDBProvider()
        cache = provider.get_metadata_cache()
        
        # Clear cache to start fresh
        cache.clear_cache()
        
        # First call should fetch from database
        table_id_1 = cache.get_table_id(tidb_connection, 'test_resources')
        assert table_id_1 is not None
        
        # Second call should use cache
        table_id_2 = cache.get_table_id(tidb_connection, 'test_resources')
        assert table_id_1 == table_id_2
        
        # Verify cache stats
        stats = cache.get_cache_stats()
        assert stats['table_ids'] >= 1
        
        # Test primary key info caching
        pk_info = cache.get_primary_key_info(tidb_connection, 'test_resources')
        assert pk_info is not None
        assert pk_info['columns'][0]['name'] == 'id'
        assert not pk_info['is_composite']
        
        # Test table existence check
        assert cache.table_exists(tidb_connection, 'test_resources') == True
        assert cache.table_exists(tidb_connection, 'nonexistent_table') == False
    
    def test_cross_entity_type_reverse_mapping(self, tidb_connection, setup_test_tables):
        """
        CRITICAL: Test reverse mapping across different entity types.
        
        This validates the generic get_entities method can find entities
        without knowing their type, using only names or storage keys.
        """
        provider = TiDBProvider()
        tenant_id = f"t{str(uuid4())[:8]}"  # Shorter tenant ID to fit column
        
        # Store multiple entity types with similar names
        resource_name = "shared_document"
        document_name = "shared_document_v2"
        
        resource_data = {
            'id': str(uuid4()),
            'name': resource_name,
            'content': 'Resource content',
            'resource_type': 'text',
            'metadata': {'type': 'resource'}
        }
        
        document_data = {
            'id': str(uuid4()),
            'title': document_name,
            'content': 'Document content'
        }
        
        # Store both entities with reverse mapping
        resource_key = provider.store_entity_with_reverse_mapping(
            connection=tidb_connection,
            entity_name=resource_name,
            entity_type='SampleResource',
            entity_data=resource_data,
            tenant_id=tenant_id
        )
        
        document_key = provider.store_entity_with_reverse_mapping(
            connection=tidb_connection,
            entity_name=document_name,
            entity_type='SampleDocument',
            entity_data=document_data,
            tenant_id=tenant_id
        )
        
        # Test retrieval by storage key without knowing entity type
        resource_retrieved = provider.get_entities_by_storage_key(
            connection=tidb_connection,
            entity_key=resource_key,
            tenant_id=tenant_id
        )
        
        document_retrieved = provider.get_entities_by_storage_key(
            connection=tidb_connection,
            entity_key=document_key,
            tenant_id=tenant_id
        )
        
        # Verify correct entities retrieved
        assert resource_retrieved['name'] == resource_name
        assert resource_retrieved['resource_type'] == 'text'
        
        assert document_retrieved['title'] == document_name  # Different field name
        assert 'content' in document_retrieved
    
    def test_tenant_isolation_in_reverse_mappings(self, tidb_connection, setup_test_tables):
        """
        CRITICAL: Test tenant isolation across all reverse mapping layers.
        
        Validates that:
        1. Entities with same names in different tenants are isolated
        2. Reverse mappings respect tenant boundaries
        3. Storage keys include tenant information
        """
        provider = TiDBProvider()
        tenant1 = f"t1{str(uuid4())[:6]}"
        tenant2 = f"t2{str(uuid4())[:6]}"
        
        # Same entity name in different tenants
        entity_name = "shared_resource_name"
        
        data1 = {
            'id': str(uuid4()),
            'name': entity_name,
            'content': 'Tenant 1 content',
            'resource_type': 'type1',
            'metadata': {'tenant': 'first'}
        }
        
        data2 = {
            'id': str(uuid4()),
            'name': entity_name,
            'content': 'Tenant 2 content',
            'resource_type': 'type2',
            'metadata': {'tenant': 'second'}
        }
        
        # Store in different tenants
        key1 = provider.store_entity_with_reverse_mapping(
            connection=tidb_connection,
            entity_name=entity_name,
            entity_type='SampleResource',
            entity_data=data1,
            tenant_id=tenant1
        )
        
        key2 = provider.store_entity_with_reverse_mapping(
            connection=tidb_connection,
            entity_name=entity_name,
            entity_type='SampleResource',
            entity_data=data2,
            tenant_id=tenant2
        )
        
        # Verify keys are different (include tenant)
        assert key1 != key2
        assert tenant1 in key1
        assert tenant2 in key2
        
        # Verify tenant isolation - each tenant only sees their own data
        retrieved1 = provider.get_entity_by_name(
            connection=tidb_connection,
            entity_name=entity_name,
            entity_type='SampleResource',
            tenant_id=tenant1
        )
        
        retrieved2 = provider.get_entity_by_name(
            connection=tidb_connection,
            entity_name=entity_name,
            entity_type='SampleResource',
            tenant_id=tenant2
        )
        
        # Verify isolation
        assert retrieved1['content'] == 'Tenant 1 content'
        assert retrieved1['metadata']['tenant'] == 'first'
        
        assert retrieved2['content'] == 'Tenant 2 content'
        assert retrieved2['metadata']['tenant'] == 'second'
        
        # Verify cross-tenant access fails
        cross_retrieved = provider.get_entity_by_name(
            connection=tidb_connection,
            entity_name=entity_name,
            entity_type='SampleResource',
            tenant_id="nonexistent_tenant"
        )
        
        assert cross_retrieved is None
    
    def test_bidirectional_lookup_consistency(self, tidb_connection, setup_test_tables):
        """
        CRITICAL: Test bidirectional lookup consistency.
        
        Validates the complete round-trip:
        name -> entity_reference -> storage_key -> reverse_mapping -> name
        """
        provider = TiDBProvider()
        tenant_id = f"t{str(uuid4())[:8]}"  # Shorter tenant ID to fit column
        entity_name = "consistency_test_resource"
        
        entity_data = {
            'id': str(uuid4()),
            'name': entity_name,
            'content': 'Consistency test content',
            'resource_type': 'test',
            'metadata': {'test': 'bidirectional'}
        }
        
        # Store with reverse mapping
        storage_key = provider.store_entity_with_reverse_mapping(
            connection=tidb_connection,
            entity_name=entity_name,
            entity_type='SampleResource',
            entity_data=entity_data,
            tenant_id=tenant_id
        )
        
        # Test bidirectional consistency
        # 1. Name -> Entity
        by_name = provider.get_entity_by_name(
            connection=tidb_connection,
            entity_name=entity_name,
            entity_type='SampleResource',
            tenant_id=tenant_id
        )
        
        # 2. Storage Key -> Entity  
        by_key = provider.get_entities_by_storage_key(
            connection=tidb_connection,
            entity_key=storage_key,
            tenant_id=tenant_id
        )
        
        # Both should return the same entity
        assert by_name is not None
        assert by_key is not None
        assert by_name['id'] == by_key['id']
        assert by_name['name'] == by_key['name']
        assert by_name['content'] == by_key['content']
        
        # Verify metadata includes reverse key information
        assert '_reverse_key_metadata' in by_name
        metadata = by_name['_reverse_key_metadata']
        assert metadata['tidb_key'] == storage_key
        assert metadata['tenant_id'] == tenant_id
        assert 'table_id' in metadata
        assert metadata['table_id'] is not None  # Real TiDB table ID