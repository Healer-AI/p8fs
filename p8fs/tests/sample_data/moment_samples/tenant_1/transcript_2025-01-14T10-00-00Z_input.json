{
  "metadata": {
    "real_world_timestamp": "2025-01-14T10:00:00Z",
    "recording_date": "Tuesday, January 14, 2025",
    "recording_time": "10:00 AM UTC"
  },
  "transcript_id": "t1_20250114_100000",
  "duration_seconds": 604,
  "start_timestamp": "2025-01-14T10:00:00Z",
  "end_timestamp": "2025-01-14T10:10:04Z",
  "source_uri": "s3://p8fs-tenant1/recordings/2025-01-14/debugging_session.wav",
  "segments": [
    {
      "timestamp": "2025-01-14T10:00:00Z",
      "speaker_id": "speaker_0",
      "speaker_label": "Alex",
      "text": "Okay this is weird. The rate limiter is returning false positives. Let me trace through this.",
      "duration_seconds": 5.8
    },
    {
      "timestamp": "2025-01-14T10:00:06Z",
      "speaker_id": "speaker_0",
      "speaker_label": "Alex",
      "text": "So the user makes a request, we check Redis... wait, the timestamp. The timestamp is in milliseconds but I'm treating it as seconds.",
      "duration_seconds": 7.9
    },
    {
      "timestamp": "2025-01-14T10:00:15Z",
      "speaker_id": "speaker_0",
      "speaker_label": "Alex",
      "text": "Oh no. That's the bug. That's definitely the bug.",
      "duration_seconds": 3.4
    },
    {
      "timestamp": "2025-01-14T10:00:19Z",
      "speaker_id": "speaker_0",
      "speaker_label": "Alex",
      "text": "Let me check the Lua script... yeah, line 12. I'm using os.time which returns seconds, but the Node timestamps are in milliseconds.",
      "duration_seconds": 8.1
    },
    {
      "timestamp": "2025-01-14T10:00:28Z",
      "speaker_id": "speaker_0",
      "speaker_label": "Alex",
      "text": "So every request looks like it happened in 1970 from Redis's perspective. That's why everything's getting rate limited.",
      "duration_seconds": 6.7
    },
    {
      "timestamp": "2025-01-14T10:00:35Z",
      "speaker_id": "speaker_0",
      "speaker_label": "Alex",
      "text": "Okay, fix is simple. Just multiply by 1000. Let me update the Lua script.",
      "duration_seconds": 5.2
    },
    {
      "timestamp": "2025-01-14T10:00:41Z",
      "speaker_id": "speaker_0",
      "speaker_label": "Alex",
      "text": "Actually no wait, I should divide the incoming timestamp by 1000, not multiply. Yeah, convert milliseconds to seconds.",
      "duration_seconds": 7.4
    },
    {
      "timestamp": "2025-01-14T10:00:49Z",
      "speaker_id": "speaker_0",
      "speaker_label": "Alex",
      "text": "Let me test this locally first before deploying. Starting the test suite...",
      "duration_seconds": 5.1
    },
    {
      "timestamp": "2025-01-14T10:00:55Z",
      "speaker_id": "speaker_0",
      "speaker_label": "Alex",
      "text": "Okay tests are running. Come on, pass pass pass.",
      "duration_seconds": 4.2
    },
    {
      "timestamp": "2025-01-14T10:01:00Z",
      "speaker_id": "speaker_0",
      "speaker_label": "Alex",
      "text": "Green! All passing. Good. Let me run the integration tests too just to be sure.",
      "duration_seconds": 5.6
    },
    {
      "timestamp": "2025-01-14T10:01:06Z",
      "speaker_id": "speaker_0",
      "speaker_label": "Alex",
      "text": "Integration tests running... this'll take a minute.",
      "duration_seconds": 3.8
    },
    {
      "timestamp": "2025-01-14T10:01:10Z",
      "speaker_id": "speaker_0",
      "speaker_label": "Alex",
      "text": "I should add a test for this specific case. Timezone handling is always a source of bugs.",
      "duration_seconds": 5.4
    },
    {
      "timestamp": "2025-01-14T10:01:16Z",
      "speaker_id": "speaker_0",
      "speaker_label": "Alex",
      "text": "Alright, integration tests passed too. I'm gonna deploy this to staging and monitor it.",
      "duration_seconds": 5.2
    }
  ],
  "speakers": [
    {
      "speaker_id": "speaker_0",
      "fingerprint_id": "fp_alex_t1",
      "user_id": "user_alex_001",
      "user_label": "Alex"
    }
  ],
  "environment": {
    "location": "home_office",
    "background_sounds": "keyboard typing, mouse clicks, occasional frustrated sigh",
    "recording_quality": "high"
  }
}
